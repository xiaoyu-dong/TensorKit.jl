<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Introduction Â· TensorKit.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">TensorKit.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li class="is-active"><a class="tocitem" href>Introduction</a><ul class="internal"><li><a class="tocitem" href="#ss_tensor-1"><span>What is a tensor?</span></a></li><li><a class="tocitem" href="#ss_symmetries-1"><span>Symmetries and block sparsity</span></a></li><li><a class="tocitem" href="#ss_categories-1"><span>Monoidal categories and their properties (optional)</span></a></li><li><a class="tocitem" href="#Bibliography-1"><span>Bibliography</span></a></li></ul></li><li><a class="tocitem" href="../spaces/">Vector spaces</a></li><li><a class="tocitem" href="../sectors/">Sectors, representation spaces and fusion trees</a></li><li><a class="tocitem" href="../tensors/">Tensors and the <code>TensorMap</code> type</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../../lib/spaces/">Vector spaces</a></li></ul></li><li><span class="tocitem">Index</span><ul><li><a class="tocitem" href="../../index/">Index</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Introduction</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Introduction</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Jutho/TensorKit.jl/blob/master/docs/src/man/intro.md" title="Edit on GitHub"><span class="docs-icon fab">ï‚›</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="s_intro-1"><a class="docs-heading-anchor" href="#s_intro-1">Introduction</a><a class="docs-heading-anchor-permalink" href="#s_intro-1" title="Permalink"></a></h1><p>Before providing a typical &quot;user guide&quot; and discussing the implementation of TensorKit.jl on the next pages, let us discuss some of the rationale behind this package.</p><h2 id="ss_tensor-1"><a class="docs-heading-anchor" href="#ss_tensor-1">What is a tensor?</a><a class="docs-heading-anchor-permalink" href="#ss_tensor-1" title="Permalink"></a></h2><p>At the very start we should ponder about the most suitable and sufficiently general definition of a tensor. A good starting point is the following:</p><ul><li><p>A tensor <span>$t$</span> is an element from the   <a href="https://en.wikipedia.org/wiki/Tensor_product">tensor product</a> of <span>$N$</span> vector spaces   <span>$V_1 , V_2, â€¦, V_N$</span>, where <span>$N$</span> is referred to as the <em>rank</em> or <em>order</em> of the   tensor, i.e.</p><p><span>$t âˆˆ V_1 âŠ— V_2 âŠ— â€¦ âŠ— V_N.$</span></p></li></ul><p>If you think of a tensor as an object with indices, a rank <span>$N$</span> tensor has <span>$N$</span> indices where every index is associated with the corresponding vector space in that it labels a particular basis in that space. We will return to index notation at the very end of this manual.</p><p>As the tensor product of vector spaces is itself a vector space, this implies that a tensor behaves as a vector, i.e. tensors from the same tensor product space can be added and multiplied by scalars. The tensor product is only defined for vector spaces over the same field, i.e. there is no meaning in <span>$â„^5 âŠ— â„‚^3$</span>. When all the vector spaces in the tensor product have an inner product, this also implies an inner product for the tensor product space. It is hence clear that the different vector spaces in the tensor product should have some form of homogeneity in their structure, yet they do not need to be all equal and can e.g. have different dimensions. It goes without saying that defining the vector spaces and their properties will be an important part of the definition of a tensor. As a consequence, this also constitutes a significant part of the implementation, and is discussed in the section on <a href="man/@ref">Vector spaces</a>.</p><p>Aside from the interpretation of a tensor as a vector, we also want to interpret it as a matrix (or more correctly, a linear map) in order to decompose tensors using linear algebra factorisations (e.g. eigenvalue or singular value decomposition). Henceforth, we use the term &quot;tensor map&quot; as follows:</p><ul><li><p>A tensor map <span>$t$</span> is a linear map from a source or <em>domain</em>   <span>$W_1 âŠ— W_2 âŠ— â€¦ âŠ— W_{N_2}$</span> to a target or <em>codomain</em> <span>$V_1 âŠ— V_2 âŠ— â€¦ âŠ— V_{N_1}$</span>, i.e.</p><p><span>$t:W_1 âŠ— W_2 âŠ— â€¦ âŠ— W_{N_2} â†’ V_1 âŠ— V_2 âŠ— â€¦ âŠ— V_{N_1}.$</span></p></li></ul><p>A <em>tensor</em> of rank <span>$N$</span> is then just a special case of a tensor map with <span>$N_1 = N$</span> and <span>$N_2 = 0$</span>. A contraction between two tensors is just a composition of linear maps (i.e. matrix multiplication), where the contracted indices correspond to the domain of the first tensor and the codomain of the second tensor.</p><p>In order to allow for arbitrary tensor contractions or decompositions, we need to be able to reorganise which vector spaces appear in the domain and the codomain of the tensor map, and in which order. This amounts to defining canonical isomorphisms between the different ways to order and partition the tensor indices (i.e. the vector spaces). For example, a linear map <span>$W â†’ V$</span> is often denoted as a rank 2 tensor in <span>$V âŠ— W^*$</span>, where <span>$W^*$</span> corresponds to the dual space of <span>$W$</span>. This simple example introduces two new concepts.</p><ol><li><p>Typical vector spaces can appear in the domain and codomain in different variants, e.g.  as normal space or dual space. In fact, the most generic case is that every vector  space <span>$V$</span> has associated with it  a <a href="https://en.wikipedia.org/wiki/Dual_space">dual space</a> <span>$V^*$</span>,  a <a href="https://en.wikipedia.org/wiki/Complex_conjugate_vector_space">conjugate space</a>  <span>$\overline{V}$</span> and a conjugate dual space <span>$\overline{V}^*$</span>. The four different  vector spaces <span>$V$</span>, <span>$V^*$</span>, <span>$\overline{V}$</span> and <span>$\overline{V}^*$</span> correspond to the  representation spaces of respectively the fundamental, dual or contragredient, complex  conjugate and dual complex conjugate representation of the general linear group  <span>$\mathsf{GL}(V)$</span> <sup class="footnote-reference"><a id="citeref-tung" href="#footnote-tung">[tung]</a></sup>. In index notation these spaces are denoted with  respectively contravariant (upper), covariant (lower), dotted contravariant  and dotted covariant indices.</p><p>For real vector spaces, the conjugate (dual) space is identical to the normal (dual)  space and we only have upper and lower indices, i.e. this is the setting of e.g.  general relativity. For (complex) vector spaces with a sesquilinear inner product  <span>$\overline{V} âŠ— V â†’ â„‚$</span>, the inner product allows to define an isomorphism from the  conjugate space to the dual space (known as  <a href="https://en.wikipedia.org/wiki/Riesz_representation_theorem">Riesz representation theorem</a>  in the more general context of Hilbert spaces).</p><p>In particular, in spaces with a Euclidean inner product (the setting of e.g. quantum  mechanics), the conjugate and dual space are naturally isomorphic (because the dual and  conjugate representation of the unitary group are the same). Again we only need upper  and lower indices (or kets and bras).</p><p>Finally, in <span>$â„^d$</span> with a Euclidean inner product, these four different spaces are  equivalent and we only need one type of index. The space is completely characterized by  its dimension <span>$d$</span>. This is the setting of much of classical mechanics and we refer to  such tensors as cartesian tensors and the corresponding space as cartesian space. These  are the tensors that can equally well be represented as multidimensional arrays (i.e.  using some <code>AbstractArray{&lt;:Real,N}</code> in Julia) without loss of structure.</p><p>The implementation of all of this is discussed in <a href="man/@ref">Vector spaces</a>.</p></li><li><p>In the generic case, the identification between maps <span>$W â†’ V$</span> and tensors in  <span>$V âŠ— W^*$</span> is not an equivalence but an isomorphism, which needs to be defined.  Similarly, there is an isomorphism between between <span>$V âŠ— W$</span> and <span>$W âŠ— V$</span> that can be  non-trivial (e.g. in the case of fermions / super vector spaces). The correct formalism  here is provided by theory of monoidal categories. Nonetheless, we try to hide these  canonical isomorphisms from the user wherever possible.</p></li></ol><p>This brings us to our final (yet formal) definition</p><ul><li>A tensor (map) is a homorphism between two objects from the category <span>$\mathbf{Vect}$</span>   (or some subcategory thereof). In practice, this will be <span>$\mathbf{FinVect}$</span>, the   category of finite dimensional vector spaces. More generally, our concept of a tensor   makes sense, in principle, for any linear (a.k.a. <span>$\mathbf{Vect}$</span>-enriched) monoidal   category. We refer to the section   &quot;<a href="man/@ref">Monoidal categories and their properties (optional)</a>&quot;.</li></ul><h2 id="ss_symmetries-1"><a class="docs-heading-anchor" href="#ss_symmetries-1">Symmetries and block sparsity</a><a class="docs-heading-anchor-permalink" href="#ss_symmetries-1" title="Permalink"></a></h2><p>Physical problems often have some symmetry, i.e. the setup is invariant under the action of a group <span>$\mathsf{G}$</span> which acts on the vector spaces <span>$V$</span> in the problem according to a certain representation. Having quantum mechanics in mind, TensorKit.jl is so far restricted to unitary representations. A general representation space <span>$V$</span> can be specified as the number of times every irreducible representation (irrep) <span>$a$</span> of <span>$\mathsf{G}$</span> appears, i.e.</p><p><span>$V = \bigoplus_{a} â„‚^{n_a} âŠ— R_a$</span></p><p>with <span>$R_a$</span> the space associated with irrep <span>$a$</span> of <span>$\mathsf{G}$</span>, which itself has dimension <span>$d_a$</span> (often called the quantum dimension), and <span>$n_a$</span> the number of times this irrep appears in <span>$V$</span>. If the unitary irrep <span>$a$</span> for <span>$g âˆˆ \mathsf{G}$</span> is given by <span>$u_a(g)$</span>, then the group action of <span>$\mathsf{G}$</span> on <span>$V$</span> is given by the unitary representation</p><p><span>$u(g) = \bigoplus_{a}  ğŸ™_{n_a} âŠ— u_a(g)$</span></p><p>with <span>$ğŸ™_{n_a}$</span> the <span>$n_a Ã— n_a$</span> identity matrix. The total dimension of <span>$V$</span> is given by <span>$âˆ‘_a n_a d_a$</span>.</p><p>The reason for implementing symmetries is to exploit the computation and memory gains resulting from restricting to tensor maps <span>$t:W_1 âŠ— W_2 âŠ— â€¦ âŠ— W_{N_2} â†’ V_1 âŠ— V_2 âŠ— â€¦ âŠ— V_{N_1}$</span> that are invariant under the symmetry (i.e. that act as <a href="https://en.wikipedia.org/wiki/Equivariant_map#Representation_theory">intertwiners</a> between the symmetry action on the domain and the codomain). Indeed, such tensors should be block diagonal because of <a href="https://en.wikipedia.org/wiki/Schur%27s_lemma">Schur&#39;s lemma</a>, but only after we couple the individual irreps in the spaces <span>$W_i$</span> to a joint irrep, which is then again split into the individual irreps of the spaces <span>$V_i$</span>. The basis change from the tensor product of irreps in the (co)domain to the joint irrep is implemented by a sequence of Clebschâ€“Gordan coefficients, also known as a fusion (or splitting) tree. We implement the necessary machinery to manipulate these fusion trees under index permutations and repartitions for arbitrary groups <span>$\mathsf{G}$</span>. In particular, this fits with the formalism of monoidal categories, and more specifically fusion categories, discussed below and only requires the <em>topological</em> data of the group, i.e. the fusion rules of the irreps, their quantum dimensions and the F-symbol (6j-symbol or more precisely Racah&#39;s W-symbol in the case of <span>$\mathsf{SU}_2$</span>). In particular, we don&#39;t actually need the Clebschâ€“Gordan coefficients themselves (but they can be useful for checking purposes).</p><p>Further details are provided in <a href="man/@ref">Sectors, representation spaces and fusion trees</a>.</p><h2 id="ss_categories-1"><a class="docs-heading-anchor" href="#ss_categories-1">Monoidal categories and their properties (optional)</a><a class="docs-heading-anchor-permalink" href="#ss_categories-1" title="Permalink"></a></h2><p>The purpose of this final introductory section (which can safely be skipped), is to explain how certain concepts and terminology from the theory of monoidal categories apply in the context of tensors.  In the end, identifying tensor manipulations in TensorKit.jl with concepts from category theory is to put the diagrammatic formulation of tensor networks in the most general context on a firmer footing. The following definitions are mostly based on <sup class="footnote-reference"><a id="citeref-selinger" href="#footnote-selinger">[selinger]</a></sup>, <sup class="footnote-reference"><a id="citeref-kassel" href="#footnote-kassel">[kassel]</a></sup> and <a href="https://ncatlab.org/"><span>$n$</span>Lab</a>, to which we refer for further information. Furthermore, we recommend the nice introduction of <a href="man/^beer">Beer et al.</a></p><p>To start, a category <span>$C$</span> consists of</p><ul><li>a class <span>$|C|$</span> of objects <span>$V$</span>, <span>$W$</span>, â€¦</li><li>for each pair of objects <span>$V$</span> and <span>$W$</span>, a set <span>$hom(W,V)$</span> of morphisms <span>$f:Wâ†’V$</span>;   for a given map <span>$f$</span>, <span>$W$</span> is called the <em>domain</em> or <em>source</em>, and <span>$V$</span> the   <em>codomain</em> or <em>target</em>.</li><li>composition of morphisms <span>$f:Wâ†’V$</span> and <span>$g:Xâ†’W$</span> into <span>$(f âˆ˜ g):Xâ†’V$</span> that is   associative, such that for <span>$h:Yâ†’X$</span> we have <span>$f âˆ˜ (g âˆ˜ h) = (f âˆ˜ g) âˆ˜ h$</span></li><li>for each object <span>$V$</span>, an identity morphism <span>$\mathrm{id}_V:Vâ†’V$</span> such that   <span>$f âˆ˜ \mathrm{id}_W = f = \mathrm{id}_V âˆ˜ f$</span>.</li></ul><p>In our case, i.e. the category <span>$\mathbf{Vect}$</span> (or some subcategory thereof), the objects are vector spaces, and the morphisms are linear maps between these vector spaces with &quot;matrix multiplication&quot; as composition. We refer to these morphisms as tensor maps exactly because there is a binary operation <span>$âŠ—$</span>, the tensor product, that allows to combine objects into new objects. This makes <span>$\mathbf{Vect}$</span> into a <strong>tensor category</strong>, a.k.a a <em>monoidal category</em>, which has</p><ul><li>a binary operation on objects <span>$âŠ—: |C| Ã— |C| â†’ |C|$</span></li><li>a binary operation on morphisms, also denoted as <span>$âŠ—$</span>, such that   <span>$âŠ—: hom(W_1,V_1) Ã— hom(W_2,V_2) â†’ hom(W_1 âŠ— W_2, V_1 âŠ— V_2)$</span></li><li>an identity object <span>$I$</span></li><li>three families of natural isomorphisms:<ul><li><span>$âˆ€ V âˆˆ |C|$</span>, a left unitor <span>$Î»_V: I âŠ— V â†’ V$</span></li><li><span>$âˆ€ V âˆˆ |C|$</span>, a right unitor <span>$Ï_V: V âŠ— I â†’ V$</span></li><li><span>$âˆ€ V_1, V_2, V_3 âˆˆ |C|$</span>, an associator   <span>$Î±_{V_1,V_2,V_3}:(V_1 âŠ— V_2) âŠ— V_3 â†’ V_1 âŠ— (V_2 âŠ— V_3)$</span></li></ul>that satisfy certain consistency conditions (coherence axioms), which are known as the   <em>triangle equation</em> and <em>pentagon equation</em>.</li></ul><p>In abstract terms, <span>$âŠ—$</span> is a (bi)functor from the product category <span>$C Ã— C$</span> to <span>$C$</span>.</p><p>For the category <span>$\mathbf{Vect}$</span>, the identity object <span>$I$</span> is just the scalar field <span>$ğ•œ$</span> over which the vector spaces are defined, and which can be identified with a one- dimensional vector space. Every monoidal category is equivalent to a strict tensor category, where the left and right unitor and associator act as the identity and their domain and codomain are truly identical. Nonetheless, for tensor maps, we do actually discriminate between <span>$V$</span>, <span>$I âŠ— V$</span> and <span>$V âŠ— I$</span> because this amounts to adding or removing an extra factor <code>I</code> to the tensor product structure of the (co)domain, i.e. the left and right unitor are analogous to removing extra dimensions of size 1 from an array, and an actual operation is required to do so (this has in fact led to some controversy in several programming languages that provide native support for multidimensional arrays). For what concerns the associator, the distinction between <span>$(V_1 âŠ— V_2) âŠ— V_3$</span> and <span>$V_1 âŠ— (V_2 âŠ— V_3)$</span> is typically absent for simple tensors or multidimensional arrays. However, this grouping can be taken to indicate how to build the fusion tree for coupling irreps to a joint irrep in the case of symmetric tensors. As such, going from one to the other requires a recoupling (F-move) which has a non-trivial action on the reduced blocks. We return to this in <a href="../sectors/#s_sectorsrepfusion-1">the section on fusion trees</a>. However, we can already note that we will always represent tensor products using a canonical order <span>$(â€¦((V_1 âŠ— V_2) âŠ— V_3) â€¦ âŠ— V_N)$</span>. A similar approach can be followed to map any tensor category into a strict tensor category (see Section XI.5 of <sup class="footnote-reference"><a id="citeref-kassel" href="#footnote-kassel">[kassel]</a></sup>).</p><p>With these definitions, we have the minimal requirements for defining tensor maps. In principle, we could use a more general definition and define tensor maps as morphism of any tensor category where the hom-sets are themselves vector spaces, such that we can add morphisms and multiply them with scalars. Furthermore, the composition of morphisms and the tensor product of morphisms are bilinear operations. Such categories are called linear or <span>$\mathbf{Vect}$</span>-enriched.</p><p>In order to make tensor (maps) useful and to define operations with them, we can now introduce additional structure or quantifiers to the tensor category for which they are the morphisms.</p><h3 id="sss_braiding-1"><a class="docs-heading-anchor" href="#sss_braiding-1">Braiding</a><a class="docs-heading-anchor-permalink" href="#sss_braiding-1" title="Permalink"></a></h3><p>To reorder tensor indices, or, equivalently, to reorder objects in the tensor product <span>$V_1 âŠ— V_2 â âŠ— â€¦ V_N$</span>, we need at the very least a <strong>braided tensor category</strong> which has, <span>$âˆ€ V, W âˆˆ |C|$</span>, a braiding <span>$Ïƒ_{V,W}: VâŠ—W â†’ WâŠ—V$</span>. A valid braiding needs to satisfy consistency condition with the associator <span>$Î±$</span> known as the <em>hexagon equation</em>.</p><p>However, for general braidings, there is no unique choice to identify a tensor in <span>$VâŠ—W$</span> and <span>$WâŠ—V$</span>, as any of the maps <span>$Ïƒ_{V,W}$</span>, <span>$Ïƒ_{W,V}^{-1}$</span>, <span>$Ïƒ_{V,W} âˆ˜ Ïƒ_{W,V} âˆ˜ Ïƒ_{V,W}$</span>, â€¦  mapping from <span>$VâŠ—W$</span> to <span>$WâŠ—V$</span> are all different. In order for there to be a unique map from <span>$V_1 âŠ— V_2 â âŠ— â€¦ V_N$</span> to any permutation of the objects in this tensor product, the braiding needs to be <em>symmetric</em>, i.e. <span>$Ïƒ_{V,W} = Ïƒ_{W,V}^{-1}$</span> or, equivalently <span>$Ïƒ_{W,V} âˆ˜ Ïƒ_{V,W} = \mathrm{id}_{VâŠ—W}$</span>. The resulting category is then referred to as a <strong>symmetric tensor category</strong>. In a graphical representation, it means that there is no distinction between over- and under- crossings and, as such, lines can just cross.</p><p>For a simple cartesian tensor, permuting the tensor indices is equivalent to applying Julia&#39;s function <code>permutedims</code> on the underlying data. Less trivial braiding implementations arise in the context of tensors with symmetries (where the fusion tree needs to be reordered) or in the case of fermions (described using so-called super vector spaces where the braiding is given by the Koszul sign rule).</p><h3 id="sss_dual-1"><a class="docs-heading-anchor" href="#sss_dual-1">Duals and pivotal structure</a><a class="docs-heading-anchor-permalink" href="#sss_dual-1" title="Permalink"></a></h3><p>For tensor maps, the braiding structure only allows to reorder the objects within the domain or within the codomain separately. An <strong>autonomous</strong> or <strong>rigid</strong> monoidal category is one where objects have duals, defined via an exact pairing, i.e. two families of canonical maps, the unit <span>$Î·_V: I â†’ V âŠ— V^*$</span> and the co-unit <span>$Ïµ_V: V^* âŠ— V â†’ I$</span> that satisfy the &quot;snake rules&quot;:</p><p><span>$Ï_V âˆ˜ (\mathrm{id}_V âŠ— Ïµ_V) âˆ˜ (Î·_V âŠ— \mathrm{id}_V) âˆ˜ Î»_V^{-1} = \mathrm{id}_V$</span></p><p><span>$Î»_{V^*}^{-1} âˆ˜ (Ïµ_V âŠ— \mathrm{id}_{V^*}) âˆ˜ (\mathrm{id}_{V^*} âŠ— Î·_V) âˆ˜ Ï_{V^*}^{-1} = \mathrm{id}_{V^*}$</span></p><p>Given a morphism <span>$t:Wâ†’V$</span>, we can now identify it with <span>$(t âŠ— \mathrm{id}_{W^*}) âˆ˜ Î·_W$</span> to obtain a morphism <span>$Iâ†’VâŠ—W^*$</span>. For the category <span>$\mathbf{Vect}$</span>, this is the identification between linear maps <span>$Wâ†’V$</span> and tensors in <span>$VâŠ—W^*$</span>. In particular, for complex vector spaces, using a bra-ket notation and a generic basis <span>${|nâŸ©}$</span> for <span>$V$</span> and dual basis <span>${âŸ¨m|}$</span> for <span>$V^*$</span> (such that <span>$âŸ¨m|nâŸ© = Î´_{m,n}$</span>), the unit is <span>$Î·_V:â„‚ â†’ V âŠ— V^*:Î± â†’ Î± âˆ‘_n |nâŸ© âŠ— âŸ¨n|$</span> and the co-unit is <span>$â Ïµ_V:V^* âŠ— V â†’ â„‚: âŸ¨m| âŠ— |nâŸ© â†’ Î´_{m,n}$</span>. Note that this does not require an inner product, i.e. no mapping from <span>$|nâŸ©$</span> to <span>$âŸ¨n|$</span> was defined.</p><p>For a general tensor map <span>$t:W_1 âŠ— W_2 âŠ— â€¦ âŠ— W_{N_2} â†’ V_1 âŠ— V_2 âŠ— â€¦ âŠ— V_{N_1}$</span>, by successively applying <span>$Î·_{W_{N_2}}$</span>, <span>$Î·_{W_{N_2-1}}$</span>, â€¦, <span>$Î·_{W_{1}}$</span> (and the left or right unitor) but no braiding, we obtain a tensor in <span>$V_1 âŠ— V_2 âŠ— â€¦ âŠ— V_{N_1} âŠ— W_{N_2}^* âŠ— â€¦ âŠ— W_{1}^*$</span>. It does makes sense to define or identify <span>$(W_1 âŠ— W_2 âŠ— â€¦ âŠ— W_{N_2})^* = W_{N_2}^* âŠ— â€¦ âŠ— W_{1}^*$</span>. Indeed, it can be shown that an exact pairing between <span>$V âŠ— W$</span> and <span>$W^* âŠ— V^*$</span> can be constructed out of the unit and counit of <span>$V$</span> and <span>$W$</span>.</p><p>These exact pairings are known as the right unit and co-unit, and <span>$V^*$</span> is the right dual of <span>$V$</span>. Likewise, then, <span>$V$</span> is a left dual of <span>$V^*$</span>, and we can also define a left dual <span>$^*V$</span> of <span>$V$</span> and associated pairings, the left unit <span>$Î·&#39;_V: I â†’ {^*V} âŠ— V$</span> and the left co-unit <span>$Ïµ&#39;_V: V âŠ— {^*V} â†’ I$</span>. An autonomous category <span>$\mathbf{C}$</span> is one where every object <span>$V$</span> has both a left and right dual. If we have a natural isomorphism between both, typically expressed via a pivotal structure <span>$Î´_V : {^*V} â†’ V^*$</span> which satisfies <span>$Î´_{V âŠ— W} = Î´_W âŠ— Î´_V$</span>, we do not have to distinguish between both. The resulting category is known as a <em>pivotal category</em>. Indeed, in TensorKit.jl we assume to be working with <strong>pivotal categories</strong> and simply refer to <code>dual(V)</code> for the dual of a vector space.</p><p>For a pivotal category, there is a well defined notion of a transpose <span>$f^*:V^* â†’ W^*$</span> (also called adjoint mate) of a morphism <span>$f:Wâ†’V$</span>, namely as as</p><p><span>$f^* = Î»_{W^*} âˆ˜ (Ïµ_V âŠ— \mathrm{id}_{W^*}) âˆ˜ (\mathrm{id}_{V^*} âŠ— f âŠ— \mathrm{id}_{W^*}) âˆ˜ (\mathrm{id}_{V^*} âŠ— Î·_{W}) âˆ˜ Ï_{V^*}^{-1}$</span></p><p><span>${^*f} = Ï_{W^*} âˆ˜ (\mathrm{id}_{W^*} âŠ— Ïµ_{V^*}) âˆ˜ (\mathrm{id}_{V^*} âŠ— f âŠ— \mathrm{id}_{W^*}) âˆ˜ (Î·_{W^*} âŠ— \mathrm{id}_{V^*}) âˆ˜ Î»_{V^*}^{-1}$</span></p><p>and both definitions coincide (which is not the case if the category is not pivotal). In a graphical representation, this means that boxes (representing tensor maps or morphisms more generally) can be rotated. The transpose corresponds to a 180Ëš rotation (either way).</p><p>Furthermore, in a pivotal category, we can define a map from endomorphisms of an object <span>$V$</span>, i.e. a morphism <span>$f:Vâ†’V$</span> to endomorphisms of the identity object <span>$I$</span>, i.e. scalars, known as the trace of <span>$f$</span>. In fact, we can define both a left trace as</p><p><span>$tr(f) = Ïµ&#39;_V âˆ˜ (f âŠ— \mathrm{id}_{V^*}) âˆ˜ Î·_V$</span></p><p>and a right trace as</p><p><span>$tr&#39;(f) = Ïµ_V âˆ˜ (\mathrm{id}_{V^*} âŠ— f) âˆ˜ Î·&#39;_V$</span></p><p>In a <strong>spherical</strong> category, both definitions coincide for all <span>$V$</span> and we simply refer to the trace of an endomorphism. The particular value <span>$d_V = tr(\mathrm{id}_V)$</span> is known as the (quantum) dimension of the object <span>$V$</span>, referred to as <code>dim(V)</code> in TensorKit.jl.</p><h3 id="sss_twists-1"><a class="docs-heading-anchor" href="#sss_twists-1">Twists and ribbons</a><a class="docs-heading-anchor-permalink" href="#sss_twists-1" title="Permalink"></a></h3><p>The braiding of a space and a dual space also follows naturally, it is given by <span>$Ïƒ_{V^*,W} = Î»_{W âŠ— V^*} âˆ˜ (Ïµ_V âŠ— \mathrm{id}_{W âŠ— V^*}) âˆ˜ (\mathrm{id}_{V^*} âŠ— Ïƒ_{V,W}^{-1} âŠ— \mathrm{id}_{V^*}) âˆ˜ (\mathrm{id}_{V^*âŠ— W} âŠ— Î·_V) âˆ˜ Ï_{V^* âŠ— W}^{-1}$</span></p><p>Furthermore, in a braided pivotal category, we can define a family of natural isomorphisms <span>$Î¸_V:Vâ†’V$</span> (i.e. for <span>$f:Wâ†’V$</span>, <span>$Î¸_V âˆ˜ f = f âˆ˜ Î¸_W$</span>) as</p><p><span>$Î¸_V = Ï_V âˆ˜ (\mathrm{id}_V âŠ— Ïµ&#39;_V) âˆ˜ (Ïƒ_{V,V} âŠ— \mathrm{id}_{V^*}) âˆ˜ (\mathrm{id}_V âŠ— Î·_V) âˆ˜ Ï_V^{-1}$</span></p><p>which satisfy</p><p><span>$Î¸_{VâŠ—W} = Ïƒ_{W,V} âˆ˜ (Î¸_W âŠ— Î¸_V) âˆ˜ Ïƒ_{V,W} = (Î¸_V âŠ— Î¸_W) âˆ˜ Ïƒ_{W,V} âˆ˜ Ïƒ_{V,W}$</span></p><p>A family of natural isomorphisms satisfying this relation is called a <strong>twist</strong>, and the resulting category is called a <strong>balanced</strong> monoidal category.  Here, we defined the twist via the exact pairings, and ultimately via the pivotal structure, i.e. the <span>$\mathrm{id}_{V^*}$</span> in the definition of <span>$Î¸_V$</span> should have been a <span>$Î´_V^{-1}$</span>. The interaction between the twist and the braiding is consistent with the graphical rules of a ribbon. However, for the graphical rules of ribbons to also be compatible with the exact pairing, we furthermore need the condition <span>$Î¸_{V^*} = Î¸_V^*$</span> (i.e. the transpose), in which case the category is said to be <strong>tortile</strong> or also a <strong>ribbon category</strong>.</p><p>Alternatively, we can start with a balanced and autonomous category and use the twist to define the pivotal structure. In particular, we can express the left unit and counit in terms of the right unit and counit, the braiding and the twist, as</p><p><span>$Î·&#39;_V = (\mathrm{id}_{V^*} âŠ— Î¸_V) âˆ˜ Ïƒ_{V,V^*} âˆ˜ Î·_V$</span></p><p><span>$Ïµ&#39;_V = Ïµ_V âˆ˜ Ïƒ_{V,V^*} âˆ˜ (Î¸_V âŠ— \mathrm{id}_{V^*})$</span></p><p>The trace of an endomorphism <span>$f:Vâ†’V$</span> is then given by</p><p><span>$tr(f) = Ïµ_V âˆ˜ Ïƒ_{V,V^*} âˆ˜ (( Î¸_V âˆ˜ f) âŠ— \mathrm{id}_{V^*}) âˆ˜ Î·_V$</span></p><p>and it can be verified using the naturality of the braiding that the resulting category is spherical, i.e. that this is equal to</p><p><span>$tr(f) = Ïµ_V âˆ˜ (\mathrm{id}_{V^*} âŠ— (f âˆ˜ Î¸_V)) âˆ˜ Ïƒ_{V,V^*} âˆ˜ Î·_V$</span></p><p>Note finally, that a ribbon category where the braiding is symmetric, is known as a <strong>compact closed category</strong>. For a symmetric braiding, the trivial twist <span>$Î¸_V = \mathrm{id}_V$</span> is always a valid choice, but it might not be the choice that one necessarily want to use. This brings us to the final paragraph.</p><h3 id="sss_adjoints-1"><a class="docs-heading-anchor" href="#sss_adjoints-1">Adjoints</a><a class="docs-heading-anchor-permalink" href="#sss_adjoints-1" title="Permalink"></a></h3><p>A final aspect of categories as they are relevant to physics, and in particular quantum physics, is the notion of an adjoint or dagger. A <strong>dagger category</strong> <span>$C$</span> is a category together with an involutive functor <span>$â€ :Câ†’C$</span> that acts as the identity on objects, whereas on morphisms <span>$f:Wâ†’V$</span> it defines a morphism <span>$f^â€ :Vâ†’W$</span> such that</p><ul><li><span>$\mathrm{id}_V^â€  = \mathrm{id}_V$</span></li><li><span>$(g âˆ˜ f)^â€  = f^â€  âˆ˜ g^â€ $</span></li><li><span>$(f^â€ )^â€  = f$</span></li></ul><p>In a dagger category, a morphism <span>$f:Wâ†’V$</span> is said to be unitary if it is an isomorphism and <span>$f^{-1} = f^â€ $</span>. Furthermore, an endomorphism <span>$f:Vâ†’V$</span> is hermitian or self-adjoint if <span>$f^â€  = f$</span>.</p><p>A dagger monoidal category is one in which the associator and left and right unitor are unitary morphisms. Similarly, a dagger braided category also has a unitary braiding, and a dagger balanced category in addition has a unitary twist.</p><p>There is more to be said about the interplay between the dagger and duals. Given a right unit <span>$Î·_V: I â†’ V âŠ— V^*$</span> and co-unit <span>$Ïµ_V: V^* âŠ— V â†’ I$</span>, we can define a left unit and co-unit <span>$Î·&#39;_V = (Ïµ_V)^â€ $</span> and <span>$Ïµ&#39;_V = (Î·_V)^â€ $</span>, and from this, a unitary pivotal structure. Hence, right autonomous dagger categories are automatically pivotal dagger categories.</p><p>The twist defined via the pivotal structure now becomes</p><p><span>$Î¸_V = Ï_V âˆ˜ (\mathrm{id}_V âŠ— (Î·_V)^â€ ) âˆ˜ (Ïƒ_{V,V} âŠ— \mathrm{id}_{V^*}) âˆ˜ (\mathrm{id}_V âŠ— Î·_V) âˆ˜ Ï_V^{-1}$</span></p><p>and is itself unitary. Even for a symmetric category, the twist defined as such must not be the identity. We will return to this in the discussion of fermions.</p><h2 id="Bibliography-1"><a class="docs-heading-anchor" href="#Bibliography-1">Bibliography</a><a class="docs-heading-anchor-permalink" href="#Bibliography-1" title="Permalink"></a></h2><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-tung"><a class="tag is-link" href="#citeref-tung">tung</a><pre><code class="language-none">    Tung, W. K. (1985). Group theory in physics: an introduction to symmetry
        principles, group representations, and special functions in classical and
        quantum physics.
        World Scientific Publishing Company.</code></pre></li><li class="footnote" id="footnote-selinger"><a class="tag is-link" href="#citeref-selinger">selinger</a><pre><code class="language-none">Selinger, P. (2010). A survey of graphical languages for monoidal
        categories.
        In New structures for physics (pp. 289-355). Springer, Berlin, Heidelberg.</code></pre></li><li class="footnote" id="footnote-beer"><a class="tag is-link" href="#citeref-beer">beer</a><pre><code class="language-none">    From categories to anyons: a travelogue
        Kerstin Beer, Dmytro Bondarenko, Alexander Hahn, Maria Kalabakov, Nicole
        Knust, Laura Niermann, Tobias J. Osborne, Christin Schridde, Stefan
        Seckmeyer, Deniz E. Stiegemann, and Ramona Wolf
        [https://arxiv.org/pdf/1811.06670.pdf](https://arxiv.org/pdf/1811.06670.pdf)</code></pre></li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../">Â« Home</a><a class="docs-footer-nextpage" href="../spaces/">Vector spaces Â»</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Saturday 28 December 2019 02:50">Saturday 28 December 2019</span>. Using Julia version 1.1.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
